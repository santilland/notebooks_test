{"version":1,"kind":"Notebook","sha256":"d1fa2460b6ed455ce85a223fe2f4026cb70dc901f361da7277123c2ee28613c8","slug":"external-notebooks.eurodatacube.notebooks.notebooks.contributions.edc-notebook-lstm","location":"/external_notebooks/eurodatacube/notebooks/notebooks/contributions/edc_notebook_lstm.ipynb","dependencies":[],"frontmatter":{"title":"South Africa Crop Type Classification on Euro Data Cube (EDC)","content_includes_title":false,"kernelspec":{"name":"conda-env-users-edcg-2023.10-01-py","display_name":"users-edcg-2023.10-01","language":"python"},"github":"https://github.com/eoxhub-workspaces/documentation/","numbering":{"title":{"offset":5}},"edit_url":"https://github.com/eoxhub-workspaces/documentation//blob/main/external_notebooks/eurodatacube/notebooks/notebooks/contributions/edc_notebook_lstm.ipynb","exports":[{"format":"ipynb","filename":"edc_notebook_lstm.ipynb","url":"/build/edc_notebook_lstm-48b1179b10b44261bd19769ad25b0388.ipynb"}]},"widgets":{},"mdast":{"type":"root","children":[{"type":"block","kind":"notebook-content","data":{},"children":[{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"This notebook shows the steps towards preparing data for training a supervised machine learning model on EDC. We will train the model based on the optical bands with 10 m resolution of Sentinel-2 imagery, i.e., the B2, B3, B4, and B8.","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"DTuY5KWq07"}],"key":"RB8R2Ua3C5"},{"type":"paragraph","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"We will use the Long Short-Term Memory model (LSTM), a variation of a recurrent neural network (RNN), which learns the temporal context of a particular yearly time series of a crop.","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"FS1QqcRG7U"}],"key":"iRaWSNmz7d"},{"type":"paragraph","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"text","value":"As for the ground truth, we will use the ","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"tEnZmXgRQ8"},{"type":"link","url":"https://collections.eurodatacube.com/south-africa-crops-competition/","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"text","value":"South Africa Crop Type Competition","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"an5ocgq6D6"}],"urlSource":"https://collections.eurodatacube.com/south-africa-crops-competition/","key":"iSSZh9GfEF"},{"type":"text","value":" collection, which is part of the EDC public collection and contains the field identification label representing the area of crop fields and the corresponding crop type collected via aerial and vehicle surveys.","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"S4aZQ9H8e6"}],"key":"ifR6erqX2k"},{"type":"paragraph","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"children":[{"type":"text","value":"In this example notebook, the expected outcome is a muticlass classifier that identifies different crop types planted in the fields in South Africa.","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"adAgc1WwuF"}],"key":"qzyXIhHBND"},{"type":"paragraph","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"children":[{"type":"text","value":"We will prepare the training data in the following steps:","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"key":"Y0voN727Gu"}],"key":"C5ayFrT1Tv"},{"type":"list","ordered":true,"start":1,"spread":false,"position":{"start":{"line":12,"column":1},"end":{"line":18,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"children":[{"type":"text","value":"Search for available ground truth labels","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"WzNIF5mKyH"}],"key":"p324jGc9nq"},{"type":"listItem","spread":true,"position":{"start":{"line":13,"column":1},"end":{"line":13,"column":1}},"children":[{"type":"text","value":"Download features and labels","position":{"start":{"line":13,"column":1},"end":{"line":13,"column":1}},"key":"lcv937egK0"}],"key":"Qz05oS4vpB"},{"type":"listItem","spread":true,"position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"text","value":"Reshape data for model training","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"key":"yEJ9rAHAkp"}],"key":"SznjwDnAXq"},{"type":"listItem","spread":true,"position":{"start":{"line":15,"column":1},"end":{"line":15,"column":1}},"children":[{"type":"text","value":"Normalize and undersample data","position":{"start":{"line":15,"column":1},"end":{"line":15,"column":1}},"key":"ffsFj8tvnd"}],"key":"EKAHWuNBNM"},{"type":"listItem","spread":true,"position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"children":[{"type":"text","value":"Train model","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"key":"HnuvLWRljB"}],"key":"JXhIjJsNEd"},{"type":"listItem","spread":true,"position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"children":[{"type":"text","value":"Run model on validation data","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"t1XWDG7IcY"}],"key":"PJ2tMgvPdk"},{"type":"listItem","spread":true,"position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"children":[{"type":"text","value":"Evaluate results","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"key":"pTxGk5g7NB"}],"key":"fUq3pbJG1h"}],"key":"AJF3pDFi6B"}],"key":"YVZz8pRPvM"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"%load_ext autoreload\n%autoreload 2","visibility":"show","key":"ETADlejySG"},{"type":"output","id":"QB0AYAi9W2Rz0xzgNW5yD","data":[],"visibility":"show","key":"e5TGN9yo7t"}],"visibility":"show","key":"ucRSUXGgQ4"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"import sys\n\nprint(sys.version)\n\n# NOTE: all necessary packages are preinstalled in the EuroDataCube curated 'edcg-2023.10-01' conda kernel!","visibility":"show","key":"AFWILOl2G8"},{"type":"output","id":"V2SvMYcr9QxR1ssUmJxaf","data":[{"name":"stdout","output_type":"stream","text":"3.10.13 | packaged by conda-forge | (main, Oct 26 2023, 18:07:37) [GCC 12.3.0]\n"}],"visibility":"show","key":"FpzopfHbSg"}],"visibility":"show","key":"F7y8lfMCfE"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"import datetime\nimport os\nimport pickle\nfrom collections import defaultdict\n\nimport contextily as cx\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport torch\nimport torch.nn.functional as F\nfrom eolearn.core import (\n    EOExecutor,\n    EOPatch,\n    EOTask,\n    EOWorkflow,\n    FeatureType,\n    OverwritePermission,\n    SaveTask,\n    linearly_connect_tasks,\n)\nfrom eolearn.features.extra.interpolation import LinearInterpolationTask\nfrom eolearn.io import SentinelHubEvalscriptTask, SentinelHubInputTask\nfrom matplotlib.colors import BoundaryNorm, ListedColormap\nfrom sentinelhub import (\n    CRS,\n    Band,\n    BBox,\n    DataCollection,\n    SentinelHubStatistical,\n    SentinelHubStatisticalDownloadClient,\n    SHConfig,\n    Unit,\n    UtmZoneSplitter,\n    bbox_to_dimensions,\n)\nfrom sklearn.metrics import accuracy_score, confusion_matrix, f1_score, precision_score, recall_score\nfrom sklearn.preprocessing import LabelEncoder, StandardScaler\nfrom torch import nn\nfrom torch.optim import Adam\nfrom torch.utils.data import DataLoader, Dataset\nfrom tqdm.auto import tqdm\n\nrng = np.random.default_rng(42)","visibility":"show","key":"BggMgtJOCC"},{"type":"output","id":"qI-hXnMcIMi4r6DP-a6m6","data":[],"visibility":"show","key":"sQ9ZG8glVG"}],"visibility":"show","key":"b4IG0xAmy7"},{"type":"block","kind":"notebook-content","data":{},"children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"1. Search for available ground truth’s labels","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"HBKJ45q8r7"}],"identifier":"id-1-search-for-available-ground-truths-labels","label":"1. Search for available ground truth’s labels","html_id":"id-1-search-for-available-ground-truths-labels","implicit":true,"key":"VBvfpC2oMk"},{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"To start preparing a training dataset, we need to find the areas which contain ground truth available in the ","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"E7rAK5hgoC"},{"type":"link","url":"https://collections.eurodatacube.com/south-africa-crops-competition/","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"South Africa Crop Type Competition","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"Kr73ZZbpXG"}],"urlSource":"https://collections.eurodatacube.com/south-africa-crops-competition/","key":"YPN5quazRt"},{"type":"text","value":" data collection on EDC. We will use the geographical coverage and the temporal availability provided on the linked webpage above to make a Catalog API request.","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"IKKVaIHElw"}],"key":"atb2HfZgq7"}],"key":"CE1sNrQC8O"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"# load the SH config\nconfig = SHConfig()\n\n# split the AOI into 2560m x 2560m tiles\nextent = BBox((17.85, -33.089240, 18.193359, -32.7), crs=CRS.WGS84)\nbbox_list = UtmZoneSplitter([extent.geometry], crs=extent.crs, bbox_size=[2560, 2560]).bbox_list","visibility":"show","key":"BMBk9ZPTPL"},{"type":"output","id":"lfKLV1nwWZiOHa1nbPzvI","data":[{"name":"stderr","output_type":"stream","text":"/home/conda/users/78c2e9a35d8f916b51e069b3359b976953e33c4ac102d2c530b5373dd8486c9d-20240215-082503-014013-382-edcg-2023.10-01/lib/python3.10/site-packages/shapely/set_operations.py:133: RuntimeWarning: invalid value encountered in intersection\n  return lib.intersection(a, b, **kwargs)\n/home/conda/users/78c2e9a35d8f916b51e069b3359b976953e33c4ac102d2c530b5373dd8486c9d-20240215-082503-014013-382-edcg-2023.10-01/lib/python3.10/site-packages/shapely/set_operations.py:133: RuntimeWarning: invalid value encountered in intersection\n  return lib.intersection(a, b, **kwargs)\n"}],"visibility":"show","key":"B9qTC7oO24"}],"visibility":"show","key":"MMjDNfbGEh"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"plt.style.use([\"default\", \"bmh\"])\nfig, ax = plt.subplots(figsize=(12, 5))\nfig.patch.set_alpha(1)\n\n# construct grid for plotting\ngrid = defaultdict(list)\nfor idx, bbox in enumerate(bbox_list):\n    grid[bbox.crs.epsg].append({\"geometry\": bbox.geometry, \"bbox_id\": idx})\n\ngdf_list = [\n    gpd.GeoDataFrame(subset, geometry=\"geometry\", crs=crs).to_crs(CRS.WGS84.epsg) for crs, subset in grid.items()\n]\ngdf = pd.concat(gdf_list).sort_values(\"bbox_id\").reset_index(drop=True)\n\n# plot grid and basemap\ngdf.plot(edgecolor=\"k\", alpha=0.2, ax=ax)\ncx.add_basemap(ax, crs=gdf.crs, source=cx.providers.OpenStreetMap.Mapnik)","visibility":"show","key":"au6RhY8164"},{"type":"output","id":"87bbW_407iQlik2aUG9GW","data":[{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"e33aa4016a1f9b7fc3affc4a543094a6","path":"/build/e33aa4016a1f9b7fc3affc4a543094a6.png"},"text/plain":{"content":"<Figure size 1200x500 with 1 Axes>","content_type":"text/plain"}}}],"visibility":"show","key":"ea4gKgfRQq"}],"visibility":"show","key":"ZYG0SMtq7Y"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"def get_coverage_request(\n    bbox: BBox,\n    time_interval: tuple[str, str],\n    evalscript: str,\n    collection: DataCollection = DataCollection.SENTINEL2_L2A,\n):\n    \"\"\"Construct request for SentinelHubStatistical data to get coverage of labels in the tile\"\"\"\n    patch_size = bbox_to_dimensions(bbox, resolution=60)\n\n    return SentinelHubStatistical(\n        aggregation=SentinelHubStatistical.aggregation(\n            evalscript=evalscript,\n            time_interval=time_interval,\n            aggregation_interval=\"P1D\",\n            size=patch_size,\n        ),\n        input_data=[SentinelHubStatistical.input_data(collection)],\n        bbox=bbox,\n    )\n\n\n# prepare evalscript for downloading crop labels\nlabels_evalscript = \"\"\"\n//VERSION=3\n\nfunction setup() {\n    return {\n        input: [\n            {\"bands\": [\"crop\", \"dataMask\"]}\n        ],\n        output: [\n            {\n                id: \"LABELS\",\n                bands: 1,\n                sampleType: \"UINT8\"\n            },\n            {\n                id: \"dataMask\",\n                bands: 1,\n                sampleType: \"UINT8\"\n            }\n        ]\n    };\n}\n\nfunction evaluatePixel(sample) {\n    return {LABELS: [sample.crop], dataMask: [sample.dataMask]};\n}\n\"\"\"\n\n# define collection which points to crop labels\ncollection_id = \"bd457670-af1b-45cd-bef2-6a7c93bf5e6e\"\nsouth_africa_crop = DataCollection.define_byoc(\n    collection_id, bands=[Band(name=\"crop\", units=(Unit.DN,), output_types=(np.uint8,))], metabands=[], is_timeless=True\n)\n\n# specify labels definition time (from webpage) and run the requests\nlabels_time_interval = (\"2017-08-01\", \"2017-08-02\")\nkwargs = dict(time_interval=labels_time_interval, evalscript=labels_evalscript, collection=south_africa_crop)\nrequests = [get_coverage_request(bbox, **kwargs).download_list[0] for bbox in bbox_list]\nclient = SentinelHubStatisticalDownloadClient()\n\n# download or load data from disk\nif not os.path.exists(\"stats.pkl\"):\n    stats = client.download(requests)\n    pickle.dump(stats, open(\"stats.pkl\", \"wb\"))\nelse:\n    stats = pickle.load(open(\"stats.pkl\", \"rb\"))","visibility":"show","key":"LOWMBwJ3Wu"},{"type":"output","id":"82utOBh0w6OEYU8JqNl_2","data":[],"visibility":"show","key":"MpcUxHvCj2"}],"visibility":"show","key":"xU1N56krtb"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"def extract_coverage(stats: list[dict]):\n    \"\"\"Extract labels coverage from the statistical data\"\"\"\n    data = stats[\"data\"][0][\"outputs\"][\"LABELS\"][\"bands\"][\"B0\"][\"stats\"]\n    return 1 - data[\"noDataCount\"] / data[\"sampleCount\"]\n\n\n# extract coverage from the stats\ncoverages = np.array([extract_coverage(s) if s[\"data\"] else 0 for s in stats])","visibility":"show","key":"ywMke2Gvuq"},{"type":"output","id":"hvsXNw4h0OSjRJqkepCjk","data":[],"visibility":"show","key":"cOBLcGJixf"}],"visibility":"show","key":"uNEjUQZERY"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"plt.style.use([\"default\", \"bmh\"])\nfig, ax = plt.subplots(figsize=(15, 5))\nfig.patch.set_alpha(1)\n\n# plot labels coverage over tiles, ignore tiles with no data\nax.hist(coverages[coverages > 0], bins=30)\nax.set_xlabel(\"Reference data coverage\");","visibility":"show","key":"fgmhxGBELL"},{"type":"output","id":"2t72REfA--XmcZgx08w5V","data":[{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"9ca6b536533a2d663a7a1012cdad50b0","path":"/build/9ca6b536533a2d663a7a1012cdad50b0.png"},"text/plain":{"content":"<Figure size 1500x500 with 1 Axes>","content_type":"text/plain"}}}],"visibility":"show","key":"E00D0mteDo"}],"visibility":"show","key":"tfefrxzhzF"},{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"","key":"mYEES5HHDh"},{"type":"output","id":"8Lcl90lmFbGGp3cUn__4g","data":[],"key":"OddmW1viBv"}],"key":"tpu1j4lSJG"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"# let's keep only the tiles with coverage above 40%\ncoverage_filter = np.array(coverages) > 0.40\nprint(f\"{np.count_nonzero(coverage_filter)} eligible patches\")\n\nfiltered = np.array(bbox_list)[coverage_filter]","visibility":"show","key":"mA5s5cyNHl"},{"type":"output","id":"btO-bAdFZOHDOBxSsD9c0","data":[{"name":"stdout","output_type":"stream","text":"63 eligible patches\n"}],"visibility":"show","key":"lMb8FQ9avA"}],"visibility":"show","key":"LnzdjwaWjf"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"plt.style.use([\"default\", \"bmh\"])\nfig, ax = plt.subplots(figsize=(12, 5))\nfig.patch.set_alpha(1)\n\n# set new column\ngdf[\"eligible\"] = coverage_filter\n\n# plot grid and basemap\ngdf.plot(color=\"none\", edgecolor=\"k\", alpha=0.2, ax=ax)\ngdf[gdf[\"eligible\"]].plot(color=\"C0\", edgecolor=\"k\", alpha=0.5, ax=ax)\ncx.add_basemap(ax, crs=gdf.crs, source=cx.providers.OpenStreetMap.Mapnik)","visibility":"show","key":"PbZKob9ImC"},{"type":"output","id":"e1lBT6Phiu525oGfRNgXd","data":[{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"692056e1100b97481d8ae22cda7d69a3","path":"/build/692056e1100b97481d8ae22cda7d69a3.png"},"text/plain":{"content":"<Figure size 1200x500 with 1 Axes>","content_type":"text/plain"}}}],"visibility":"show","key":"hyFkCFLw2w"}],"visibility":"show","key":"cBGa99Z2rL"},{"type":"block","kind":"notebook-content","data":{},"children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"2. Download features and labels","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"PbmTQRgGel"}],"identifier":"id-2-download-features-and-labels","label":"2. Download features and labels","html_id":"id-2-download-features-and-labels","implicit":true,"key":"oJ1iwbZGTj"},{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"Now we know where the groud truth is available, we use eo-learn to download the data and the labels. This is what the eo-learn workflow does:","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"qDXENWBvpd"}],"key":"pBKtaIspEU"},{"type":"list","ordered":true,"start":1,"spread":false,"position":{"start":{"line":4,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"children":[{"type":"text","value":"Download bands data (B, G, R, NIR)","position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"key":"IB5nC9RU8W"}],"key":"DSqEob63or"},{"type":"listItem","spread":true,"position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"Download labels data","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"iLCbumQzI0"}],"key":"QQbVCVdr31"},{"type":"listItem","spread":true,"position":{"start":{"line":6,"column":1},"end":{"line":6,"column":1}},"children":[{"type":"text","value":"Construct valid mask from data availability mask and cloud mask","position":{"start":{"line":6,"column":1},"end":{"line":6,"column":1}},"key":"yfz7YYoDa5"}],"key":"aQTUQjZoJd"},{"type":"listItem","spread":true,"position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"text","value":"Perform temporal interpolation and resample to uniform timestamps across whole AOI","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"VJSxJqafWc"}],"key":"fVQ6bBJY9U"}],"key":"suJp9b6Go8"}],"key":"sw9f9flAZf"},{"type":"block","kind":"notebook-content","data":{},"children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"For the purpose of this notebook, we will download only 2 EOPatches, but to properly train the model, set the ","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"ZulABOMLwy"},{"type":"inlineCode","value":"tutorial_mode","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"cJHj1HaMbT"},{"type":"text","value":" to ","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"dpMelrengF"},{"type":"inlineCode","value":"False","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"kjabrophWZ"},{"type":"text","value":" to properly train the model","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"EF1aIgAdj8"}],"key":"S5MCKReba2"}],"key":"XcePpnr93X"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"tutorial_mode = True\nif tutorial_mode:  # select first two eligible EOPatches\n    subset = [18, 20]\n    selected = filtered[subset]\n    gdf[\"selected\"] = False\n    gdf.loc[gdf.loc[gdf.eligible].index[subset], \"selected\"] = True\nelse:  # select all eligible EOPatches\n    selected = filtered\n    gdf[\"selected\"] = coverage_filter","visibility":"show","key":"MOVRUBqtME"},{"type":"output","id":"YEb50fDMXdk6hHVYXCTy2","data":[],"visibility":"show","key":"QMlZhDDi3r"}],"visibility":"show","key":"yzdH6nSQUI"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"# prepare task for joining valid data mask and cloud masks from SH\nclass SentinelHubValidDataTask(EOTask):\n    \"\"\"\n    Combine the downloaded cloud mask with `IS_DATA` to define a valid data mask\n    The SentinelHub's cloud mask is expected in eopatch.mask['CLM']\n    \"\"\"\n\n    def __init__(self, output_feature):\n        self.output_feature = output_feature\n\n    def execute(self, eopatch):\n        eopatch[self.output_feature] = eopatch.mask[\"IS_DATA\"].astype(bool) & (~eopatch.mask[\"CLM\"].astype(bool))\n        return eopatch\n\n\n# BAND DATA\n# Add a request for S2 bands.\n# Here we also do a simple filter of cloudy scenes (on tile level).\n# The s2cloudless masks are requested via additional data.\nband_names = [\"B02\", \"B03\", \"B04\", \"B08\"]\nadd_data = SentinelHubInputTask(\n    bands_feature=(FeatureType.DATA, \"BANDS\"),\n    bands=band_names,\n    resolution=10,\n    maxcc=0.8,\n    time_difference=datetime.timedelta(minutes=120),\n    data_collection=DataCollection.SENTINEL2_L2A,\n    additional_data=[(FeatureType.MASK, \"dataMask\", \"IS_DATA\"), (FeatureType.MASK, \"CLM\")],\n    max_threads=5,\n)\n\n# LABELS DATA\n# Add a request for crop labels.\nadd_labels = SentinelHubEvalscriptTask(\n    features=(FeatureType.MASK_TIMELESS, \"LABELS\"),\n    evalscript=labels_evalscript,\n    data_collection=south_africa_crop,\n    resolution=10,\n    max_threads=5,\n)\n\n# VALIDITY MASK\n# Validate pixels using SentinelHub's cloud detection mask and region of acquisition\nadd_sh_validmask = SentinelHubValidDataTask((FeatureType.MASK, \"IS_VALID\"))\n\n# LINEAR TEMPORAL INTERPOLATION\n# linear interpolation of full time-series and date resampling\n# needed to evaluate time series at specific dates for all data\ntime_interval = (\"2017-01-01\", \"2017-12-31\")\nresampled_range = (time_interval[0], time_interval[1], 15)  # define target timestamps (every 15 days)\nlinear_interp = LinearInterpolationTask(\n    (FeatureType.DATA, \"BANDS\"),  # name of field to interpolate\n    mask_feature=(FeatureType.MASK, \"IS_VALID\"),  # mask to be used in interpolation\n    copy_features=[(FeatureType.MASK_TIMELESS, \"LABELS\")],  # features to keep\n    resample_range=resampled_range,\n)\n\n# SAVING TO OUTPUT\nsave = SaveTask(\"./eopatches\", overwrite_permission=OverwritePermission.OVERWRITE_FEATURES)","visibility":"show","key":"svCGPBvTDq"},{"type":"output","id":"tHSdQVrqztZv76PtzDgVl","data":[],"visibility":"show","key":"Wrevgj7MME"}],"visibility":"show","key":"mYlWz4Cdy6"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"# Define the workflow\nworkflow_nodes = linearly_connect_tasks(\n    add_data,\n    add_labels,\n    add_sh_validmask,\n    linear_interp,\n    save,\n)\nworkflow = EOWorkflow(workflow_nodes)\n\n# Define additional parameters of the workflow\ninput_bands = workflow_nodes[0]\nsave_node = workflow_nodes[-1]\nexecution_args = []\nfor idx, bbox in enumerate(selected):\n    execution_args.append(\n        {\n            input_bands: {\"bbox\": bbox, \"time_interval\": time_interval},\n            save_node: {\"eopatch_folder\": f\"eopatch_{idx}\"},\n        }\n    )\n\n# Execute the workflow\nif not os.path.exists(\"eopatches\"):\n    executor = EOExecutor(workflow, execution_args, save_logs=True)\n    executor.run(workers=2)","visibility":"show","key":"MQVZBoUIPf"},{"type":"output","id":"I_rFH4vwSmxGT4CTH2oIk","data":[{"output_type":"display_data","metadata":{},"data":{"application/vnd.jupyter.widget-view+json":{"content":"{\"model_id\":\"5224204b0f364154932cacb96d19746f\",\"version_major\":2,\"version_minor\":0}","content_type":"application/vnd.jupyter.widget-view+json"},"text/plain":{"content":"  0%|          | 0/2 [00:00<?, ?it/s]","content_type":"text/plain"}}}],"visibility":"show","key":"lo3Q6ZHbXJ"}],"visibility":"show","key":"g4naKqHYm5"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"# collect the data and labels over all eopatches\ndata_list = []\nlabels_list = []\nfor eop_idx in tqdm(range(len(selected))):\n    eop = EOPatch.load(f\"./eopatches/eopatch_{eop_idx}\")\n    data_list.append(eop.data[\"BANDS\"])\n    labels_list.append(eop.mask_timeless[\"LABELS\"])","visibility":"show","key":"gI10KOHDZq"},{"type":"output","id":"U5j29bPI_z9UWghwwkVWj","data":[],"visibility":"show","key":"eQK12cp9og"}],"visibility":"show","key":"lnbpXqoF0c"},{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"# plot selected scenes in true color\nncols = 2\nnrows = 1\ntime_idx = 12\n\nplt.style.use([\"default\", \"bmh\"])\nfig, axs = plt.subplots(ncols=ncols, nrows=nrows, figsize=(ncols * 2, nrows * 2))\nfig.patch.set_alpha(1)\n\nfor ax, image in zip(axs.flatten(), data_list):\n    ax.imshow(np.clip(image[time_idx][..., [2, 1, 0]] * 3.5, 0, 1))\n    ax.axis(\"off\")\n\nplt.tight_layout()","key":"GeGHb40VaG"},{"type":"output","id":"MXBnwGZLsPJrIQtFGW2Wd","data":[],"key":"noC7RKTVBx"}],"key":"bRdodOUE3Z"},{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"# plot also labels\nncols = 2\nnrows = 1\n\nlabel_codes = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nlabel_colors = [\n    \"#ffffff\",\n    \"#a6cee3\",\n    \"#1f78b4\",\n    \"#b2df8a\",\n    \"#33a02c\",\n    \"#fb9a99\",\n    \"#e31a1c\",\n    \"#fdbf6f\",\n    \"#ff7f00\",\n    \"#cab2d6\",\n]\nlabel_text = [\n    \"No data\",\n    \"Lucerne/Medics\",\n    \"Planted pastures (perennial)\",\n    \"Fallow\",\n    \"Wine grapes\",\n    \"Weeds\",\n    \"Small grain grazing\",\n    \"Wheat\",\n    \"Canola\",\n    \"Rooibos\",\n]\n\nplt.style.use([\"default\", \"bmh\"])\nfig, axs = plt.subplots(ncols=ncols, nrows=nrows, figsize=(ncols * 2, nrows * 2))\nfig.patch.set_alpha(1)\n\ncmap = ListedColormap(label_colors)\nnorm = BoundaryNorm(label_codes, 10)\n\nfor ax, image in zip(axs.flatten(), labels_list):\n    ax.imshow(image.squeeze(-1), cmap=cmap, norm=norm, interpolation=\"none\")\n    ax.axis(\"off\")\n\nplt.tight_layout()","key":"ezTKe2GML2"},{"type":"output","id":"GBiU6GamgoFglG4A_cP8F","data":[],"key":"snTjLUYldO"}],"key":"TVOo8cia4v"},{"type":"block","kind":"notebook-content","data":{},"children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"3. Reshape data for model training","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"Ql2OBsL6BL"}],"identifier":"id-3-reshape-data-for-model-training","label":"3. Reshape data for model training","html_id":"id-3-reshape-data-for-model-training","implicit":true,"key":"QnQAb2b0Pi"},{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"The data for the LSTM model needs to be in the form of ","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"Li3v6HmA1A"},{"type":"inlineCode","value":"N x T x C","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"gS5VfY4kX0"},{"type":"text","value":", where ","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"GyQhUWpBvy"},{"type":"emphasis","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"N","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"U9RarJ54YR"}],"key":"nqEJN5YNWG"},{"type":"text","value":" represents the number of pixels, ","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"NQIWoIwl54"},{"type":"emphasis","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"T","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"qYaEbCB1Ps"}],"key":"kM5ytBJqgH"},{"type":"text","value":" represents the number of timestamps, and ","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"HDJXyLVzGF"},{"type":"emphasis","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"C","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"X6LUnKZ6mj"}],"key":"FzW2Ae6gF1"},{"type":"text","value":" the number of channels.","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"FHYh0H5PGS"}],"key":"KFfd0lG9ym"},{"type":"paragraph","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"We have 25 timestamps and 4 channels (B, G, R, NIR).","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"JHq4GdMyxJ"}],"key":"buVMppx82H"}],"key":"gkwmGkWObj"},{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"# split tiles into train and validation patches\ntrain_slice = slice(None, None, 2)  # evens\nval_slice = slice(1, None, 2)  # odds\n\ntrain_data, train_labels = data_list[train_slice], labels_list[train_slice]\nvalidate_data, validate_labels = data_list[val_slice], labels_list[val_slice]\n\nsel_gdf = gdf[gdf.selected].copy()\nsel_gdf[\"train_split\"] = False\nsel_gdf.loc[train_slice, \"train_split\"] = True\n\nplt.style.use([\"default\", \"bmh\"])\nfig, ax = plt.subplots(figsize=(12, 5))\nfig.patch.set_alpha(1)\n\n# plot grid and basemap\ngdf.plot(color=\"none\", edgecolor=\"k\", alpha=0.2, ax=ax)\nsel_gdf[sel_gdf.train_split].plot(color=\"xkcd:green\", edgecolor=\"k\", alpha=0.2, ax=ax)\nsel_gdf[~sel_gdf.train_split].plot(color=\"xkcd:brick\", edgecolor=\"k\", alpha=0.2, ax=ax)\ncx.add_basemap(ax, crs=gdf.crs, source=cx.providers.OpenStreetMap.Mapnik)","key":"BP3LIhnwjT"},{"type":"output","id":"lSsA9tlHVefexYYEe9ML0","data":[],"key":"wfqja0P39x"}],"key":"ZWW3Mm8cxj"},{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"# function for extracting and reshaping the data and labels\ndef get_model_input(data: np.ndarray, labels: np.ndarray) -> tuple:\n    t, h, w, d = data.shape\n    x = np.reshape(np.moveaxis(data, 0, -2), (h * w, t, d))  # N x T x C\n    y = np.reshape(labels, (h * w))\n    return x[y != 0], y[y != 0]","key":"DIf3UmAZRb"},{"type":"output","id":"U3nysOptIO-WA-mLBCLo-","data":[],"key":"S3qcV50FsG"}],"key":"jCbiKkiWc5"},{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"# reshape for train data\nx_train, y_train = [], []\nfor data, labels in zip(train_data, train_labels):\n    model_input = get_model_input(data, labels)\n    x_train.append(model_input[0])\n    y_train.append(model_input[1])\n\nx_train = np.concatenate(x_train, axis=0).astype(np.float32)\ny_train = np.concatenate(y_train, axis=0).astype(np.uint8)\ndel train_data, train_labels\n\nprint(x_train.shape)\nprint(y_train.shape)","key":"Lv7Z3SvKsk"},{"type":"output","id":"qv1omFrWtht8A6fCVO_Bl","data":[],"key":"Pr0fiJLiBB"}],"key":"eYbZmyJV2Y"},{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"# reshape for validation data\nx_validate, y_validate = [], []\nfor data, labels in zip(validate_data, validate_labels):\n    model_input = get_model_input(data, labels)\n    x_validate.append(model_input[0])\n    y_validate.append(model_input[1])\n\nx_validate = np.concatenate(x_validate, axis=0).astype(np.float32)\ny_validate = np.concatenate(y_validate, axis=0).astype(np.uint8)\ndel validate_data, validate_labels\n\nprint(x_validate.shape)\nprint(y_validate.shape)","key":"EtkJQv2eWP"},{"type":"output","id":"1Z73lEpcMzrffoIUNe02r","data":[],"key":"j3FRllgjjB"}],"key":"cqBowsjSti"},{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"plt.style.use([\"default\", \"bmh\"])\nfig, ax = plt.subplots(figsize=(15, 5), ncols=2, sharex=True)\nfig.patch.set_alpha(1)\n\nlabels_dict = dict(zip(label_codes, label_text))\n\nlabels, counts = np.unique(y_train, return_counts=True)\nax[0].barh(range(len(labels)), counts)\nax[0].set_title(\"Train data labels distribution\")\nax[0].set_yticks(range(len(labels)), [labels_dict[lbl] for lbl in labels])\n\nlabels, counts = np.unique(y_validate, return_counts=True)\nax[1].barh(range(len(labels)), counts)\nax[1].set_title(\"Validation data labels distribution\")\nax[1].set_yticks(range(len(labels)), [labels_dict[lbl] for lbl in labels])\n\nplt.tight_layout()","key":"ssHRZ4w4Ge"},{"type":"output","id":"bMWLdtXrTL3oIDU4U0lRp","data":[],"key":"NeWurqdt5C"}],"key":"XbzhsxjH4Z"},{"type":"block","kind":"notebook-content","data":{},"children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"4. Normalize and undersample data","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"XwgpDnc0nL"}],"identifier":"id-4-normalize-and-undersample-data","label":"4. Normalize and undersample data","html_id":"id-4-normalize-and-undersample-data","implicit":true,"key":"A4u5iXYt9F"},{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"For the columns that contain numerical data, we should ensure the data range is normalized in case the data has different scales. This process may improve the models performance, and also preserve outliers.","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"WZYfa0jjiJ"}],"key":"NxhDl2PrfD"},{"type":"paragraph","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"Here we will use a simple method of undersampling just to minimize the amount of huge data we are handling, but the balance of the classes will remain the same.","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"Vav55O4a6d"}],"key":"B3QSbKzv2H"}],"key":"EFy3P9V4YY"},{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"# set random seet\nnp.random.seed(42)\n\n# define percentage of data to use\npercentage = 0.3\n\n# sample train data\nsample_mask = np.random.choice(x_train.shape[0], int(percentage * x_train.shape[0]))\nclass_counts_before = np.unique(y_train, return_counts=True)\nx_train = x_train[np.sort(sample_mask)]\ny_train = y_train[np.sort(sample_mask)]\nclass_counts_after = np.unique(y_train, return_counts=True)\n\n# sample validation data\nsample_mask_val = np.random.choice(x_validate.shape[0], int(percentage * x_validate.shape[0]))\nx_validate = x_validate[sample_mask_val]\ny_validate = y_validate[sample_mask_val]\n\n# normalize train data\nn, t, c = x_train.shape\nx_train = StandardScaler().fit_transform(x_train.reshape(n * t, c)).reshape(n, t, c)\n\n# normalize validation data\nn, t, c = x_validate.shape\nval_scaler = StandardScaler().fit(x_validate.reshape(n * t, c))\nx_validate = val_scaler.transform(x_validate.reshape(n * t, c)).reshape(n, t, c)\n\n# check shapes\nx_train.shape, x_validate.shape","key":"iOs4lQXs3k"},{"type":"output","id":"AFvWvs8QZcSokwIMVzeGe","data":[],"key":"C5eYIpSlzC"}],"key":"TYfpWBHNYZ"},{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"# fill nan values with -1\nx_train = np.nan_to_num(x_train, nan=-1)\nx_validate = np.nan_to_num(x_validate, nan=-1)","key":"FyIV0Yv1AG"},{"type":"output","id":"CGvL8wZrJ4dJoO4FGkHmB","data":[],"key":"Fcr6PAQS80"}],"key":"DGpz7xaRKr"},{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"# check labels distribution before and after undersampling\nplt.style.use([\"default\", \"bmh\"])\nfig, axs = plt.subplots(figsize=(12, 7), ncols=2)\nfig.patch.set_alpha(1)\n\nlabels_dict = dict(zip(label_codes, label_text))\ncolors_dict = dict(zip(label_codes, label_colors))\n\naxs[0].pie(\n    class_counts_before[1],\n    labels=[labels_dict[lbl] for lbl in class_counts_before[0]],\n    autopct=\"%1.1f%%\",\n    colors=[colors_dict[lbl] for lbl in class_counts_before[0]],\n    wedgeprops={\"linewidth\": 2, \"edgecolor\": \"white\", \"alpha\": 0.7},\n)\naxs[0].set_title(\"Class Distribution Before Undersampling\")\n\naxs[1].pie(\n    class_counts_after[1],\n    labels=[labels_dict[lbl] for lbl in class_counts_after[0]],\n    autopct=\"%1.1f%%\",\n    colors=[colors_dict[lbl] for lbl in class_counts_after[0]],\n    wedgeprops={\"linewidth\": 2, \"edgecolor\": \"white\", \"alpha\": 0.7},\n)\naxs[1].set_title(\"Class Distribution After Undersampling\")\n\nplt.tight_layout()","key":"CxHQXLtTVs"},{"type":"output","id":"-OqP5BoD857rxWDHeyaSW","data":[],"key":"LcInEONn5R"}],"key":"hI3JTEJTj0"},{"type":"block","kind":"notebook-content","data":{},"children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"5. Train the model","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"ZFRmUzT2OK"}],"identifier":"id-5-train-the-model","label":"5. Train the model","html_id":"id-5-train-the-model","implicit":true,"key":"KabPMUmEH5"},{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"Now it’s time to construct and train the LSTM model. First we need a bunch of classes that the model will use, from the dataloaders to the model itself.","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"JaZL7XZbnF"}],"key":"H6TWlOgUej"}],"key":"gkB0d4o5n8"},{"type":"block","kind":"notebook-content","data":{},"children":[{"type":"heading","depth":4,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Define the data loaders","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"wGKBqV2Svg"}],"identifier":"define-the-data-loaders","label":"Define the data loaders","html_id":"define-the-data-loaders","implicit":true,"key":"HZCSUNkmIC"}],"key":"czP4KYYUbu"},{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"# class for the dataloader\nclass CustomImageDataset(Dataset):\n    def __init__(self, x_data: np.ndarray, y_data: np.ndarray, encoder: LabelEncoder):\n        self.x_data = x_data\n        self.y_data = encoder.transform(y_data)\n\n    def __len__(self):\n        return len(self.y_data)\n\n    def __getitem__(self, idx):\n        return self.x_data[idx], self.y_data[idx]\n\n\n# encode labels to 0 - num_labels\nencoder = LabelEncoder().fit(list(set(y_train) | set(y_validate)))\nfor lbl in encoder.classes_:\n    print(f\"{lbl} -> {encoder.transform([lbl])[0]}\")","key":"a0hWhM13Wa"},{"type":"output","id":"pFvdR86WT9ERrTljCGtX7","data":[],"key":"AIQ4adzhXV"}],"key":"LukNKMPBtZ"},{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"# define the batch size and the dataloaders for train/validation data\nBATCH_SIZE = 1024 if tutorial_mode else 4096\ntrain_dataloader = DataLoader(CustomImageDataset(x_train, y_train, encoder), batch_size=BATCH_SIZE, shuffle=True)\nvalidation_dataloader = DataLoader(\n    CustomImageDataset(x_validate, y_validate, encoder), batch_size=BATCH_SIZE, shuffle=True\n)","key":"jkwDoY0qcw"},{"type":"output","id":"gIKY9RuGNed97osRf_lEn","data":[],"key":"TntwsBDjrv"}],"key":"iphdLKY8Vx"},{"type":"block","kind":"notebook-content","data":{},"children":[{"type":"heading","depth":3,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Define the model architecture","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"ZUQ6Auusvy"}],"identifier":"define-the-model-architecture","label":"Define the model architecture","html_id":"define-the-model-architecture","implicit":true,"key":"DWfbmfju0B"}],"key":"y3ES0RMYTk"},{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"class AverageMetric:\n    \"\"\"\n    Simple class for averaging metrics.\n    \"\"\"\n\n    def __init__(self):\n        self.values = list()\n\n    def add(self, new):\n        self.values.append(new)\n\n    def get(self):\n        return np.array(self.values).mean()\n\n\n# This code is taken from https://github.com/TUM-LMF/BreizhCrops\nclass LSTM(nn.Module):\n    \"\"\"\n    Implementation of the LSTM model for classification of a input sequence into n classes.\n\n    :param input_dim: number of input features entering LSTM cell (i.e. 13 if all S2 bands are used)\n    :type input_dim: int\n    :param n_classes: number of classes\n    :type n_classes: int (class labels have to be between 0 and n_classes-1)\n    :param hidden_dims: The number of features in the hidden state `h`\n    :type hidden_dims: int\n    :param num_rnn_layers: Number of recurrent layers. E.g., setting ``num_layers=2``\n                           would mean stacking two LSTMs together to form a `stacked LSTM`,\n                           with the second LSTM taking in outputs of the first LSTM and\n                           computing the final results.\n    :type num_rnn_layers: int\n    :param dropout: If non-zero, introduces a `Dropout` layer on the outputs of each\n                    LSTM layer except the last layer, with dropout probability equal to\n                    :attr:`dropout`.\n    :type dropout: float (between 0.0 and 1.0)\n    :param bidirectional: If ``True``, becomes a bidirectional LSTM.\n    :type bidirectional: bool\n    :param use_batchnorm: If ``True``, use batch normalization.\n    :type use_batchnorm: bool\n    :param use_layernorm: If ``True``, applies Layer Normalization over a mini-batch of inputs.\n    :type use_layernorm: bool\n    \"\"\"\n\n    def __init__(\n        self,\n        input_dim,\n        n_classes,\n        hidden_dims,\n        num_rnn_layers=1,\n        dropout=0,\n        bidirectional=False,\n        use_batchnorm=False,\n        use_layernorm=True,\n    ):\n        super().__init__()\n\n        self.nclasses = n_classes\n        self.use_batchnorm = use_batchnorm\n        self.use_layernorm = use_layernorm\n\n        self.d_model = num_rnn_layers * hidden_dims\n        if use_layernorm:\n            self.inlayernorm = nn.LayerNorm(input_dim)\n            self.clayernorm = nn.LayerNorm((hidden_dims + hidden_dims * bidirectional) * num_rnn_layers)\n\n        self.lstm = nn.LSTM(\n            input_size=input_dim,\n            hidden_size=hidden_dims,\n            num_layers=num_rnn_layers,\n            bias=False,\n            batch_first=True,\n            dropout=dropout,\n            bidirectional=bidirectional,\n        )\n\n        if bidirectional:\n            hidden_dims = hidden_dims * 2\n\n        self.linear_class = nn.Linear(hidden_dims * num_rnn_layers, n_classes, bias=True)\n\n        if use_batchnorm:\n            self.bn = nn.BatchNorm1d(hidden_dims)\n\n    def _logits(self, x):\n        x = x.transpose(1, 2)\n\n        if self.use_layernorm:\n            x = self.inlayernorm(x)\n\n        outputs, last_state_list = self.lstm.forward(x)\n\n        # TODO: check what is goinig on here\n        if self.use_batchnorm:\n            b, t, d = outputs.shape\n            o_ = outputs.view(b, -1, d).permute(0, 2, 1)\n            outputs = self.bn(o_).permute(0, 2, 1).view(b, t, d)\n\n        h, c = last_state_list\n\n        nlayers, batchsize, n_hidden = c.shape\n        # TODO: shouldn't this be executed only uf layernorm is True\n        h = self.clayernorm(c.transpose(0, 1).contiguous().view(batchsize, nlayers * n_hidden))\n        logits = self.linear_class.forward(h)\n\n        return logits\n\n    def forward(self, x):\n        logits = self._logits(x)\n        logprobabilities = F.log_softmax(logits, dim=-1)\n        return logprobabilities\n\n    def save(self, path=\"model.pth\", **kwargs):\n        model_state = self.state_dict()\n        os.makedirs(os.path.dirname(path), exist_ok=True)\n        torch.save(dict(model_state=model_state, **kwargs), path)\n\n    def load(self, path):\n        snapshot = torch.load(path, map_location=\"cpu\")\n        model_state = snapshot.pop(\"model_state\", snapshot)\n        self.load_state_dict(model_state)\n        return snapshot\n\n    def update_and_freeze_body(self, pretrained, freeze_layers=(0, -1)):\n        self.inlayernorm = pretrained.inlayernorm\n        self.clayernorm = pretrained.clayernorm\n        self.lstm = pretrained.lstm\n\n        for child in list(self.children())[freeze_layers[0] : freeze_layers[1]]:\n            for param in child.parameters():\n                param.requires_grad = False\n\n    def unfreeze(self):\n        for child in self.children():\n            for param in child.parameters():\n                param.requires_grad = True\n\n\ndef train(model, optimizer, train_loader, validation_loader, epochs):\n    \"\"\"\n    Vanilla function to run the inference on all train samples given in training dataloader.\n    At each epoch end the loss and accuracy of samples from the validation loader are printed.\n    \"\"\"\n    model.train()\n\n    if torch.cuda.is_available():\n        model = model.cuda()\n\n    for epoch in range(epochs):\n        # train phase\n        train_loss_log = AverageMetric()\n        model.train()\n        for data in train_loader:\n            optimizer.zero_grad()\n\n            inputs, targets = data\n\n            if torch.cuda.is_available():\n                inputs = inputs.cuda()\n                targets = targets.cuda()\n\n            logprobabilities = model.forward(inputs.transpose(1, 2))\n\n            loss = torch.nn.functional.nll_loss(logprobabilities, targets)\n            train_loss_log.add(loss.cpu().detach().numpy())\n\n            loss.backward()\n            optimizer.step()\n\n        # val phase\n        val_loss_log = AverageMetric()\n        model.eval()\n        predictions_list = list()\n        targets_list = list()\n        for _, data in enumerate(validation_loader):\n            inputs, targets = data\n\n            if torch.cuda.is_available():\n                inputs = inputs.cuda()\n                targets = targets.cuda()\n\n            logprobabilities = model.forward(inputs.transpose(1, 2))\n            loss = torch.nn.functional.nll_loss(logprobabilities, targets)\n            val_loss_log.add(loss.cpu().detach().numpy())\n\n            targets_list.append(targets.cpu().detach().numpy())\n            predictions_list.append((logprobabilities.cpu().detach().numpy()).argmax(1))\n\n        val_acc = accuracy_score(np.concatenate(targets_list), np.concatenate(predictions_list))\n        print(\n            f\"Epoch {epoch}: train loss {train_loss_log.get():.3f} | \"\n            f\"val loss {val_loss_log.get():.3f} | \"\n            f\"val acc = {val_acc:.3f}\"\n        )\n\n    return model","key":"GNtWEsIlUY"},{"type":"output","id":"vpYzymOsJTY7-zvG93HF-","data":[],"key":"FIrhIY67On"}],"key":"T5XkMx9cqw"},{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"# set up the model\nmodel = LSTM(\n    input_dim=x_train.shape[-1],\n    n_classes=len(encoder.classes_),\n    hidden_dims=128,\n    num_rnn_layers=3,\n    dropout=0.1,\n    bidirectional=True,\n    use_batchnorm=False,\n    use_layernorm=True,\n)\n\n# set up the optimizer\noptimizer = Adam(model.parameters(), lr=5e-5)","key":"wZ26AZJYVZ"},{"type":"output","id":"F2NMNpxV-ed9ZeebtlS4q","data":[],"key":"GeIkoEVrvP"}],"key":"Yun0zr18TQ"},{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"model_path = \"./model.pth\"\nif not os.path.exists(model_path):\n    n_epochs = 2 if tutorial_mode else 50\n    # train the model for a few epochs and save when training is done\n    model = train(model, optimizer, train_dataloader, validation_dataloader, epochs=n_epochs)\n    model.save(model_path)\nelse:\n    # or load the saved model from path\n    model = LSTM(\n        input_dim=x_train.shape[-1],\n        n_classes=len(encoder.classes_),\n        hidden_dims=128,\n        num_rnn_layers=3,\n        dropout=0.1,\n        bidirectional=True,\n        use_batchnorm=False,\n        use_layernorm=True,\n    )\n    model.load(model_path)\n    model.eval()","key":"VSQkNHfFDK"},{"type":"output","id":"MIhMkaoLIJnsYbwpuaJYc","data":[],"key":"AHilfr2DZh"}],"key":"AOmILQdelf"},{"type":"block","kind":"notebook-content","data":{},"children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"6. Run the model on validation data","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"gtaVJAl9YT"}],"identifier":"id-6-run-the-model-on-validation-data","label":"6. Run the model on validation data","html_id":"id-6-run-the-model-on-validation-data","implicit":true,"key":"qEUNWUAKYO"},{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"Now that the model is trained, let’s run it on the validation data and see how well it performs.","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"aURwTGO8kP"}],"key":"t7vF0so1Px"}],"key":"DzmDXBHcnF"},{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"# convert validation data to the proper format for inference\nn_samples = 2000 if tutorial_mode else 10000\nval_sample_mask = np.random.choice(range(len(x_validate)), n_samples)\nval_tensor = torch.from_numpy(x_validate[val_sample_mask]).transpose(1, 2)\nlogprobas = model.forward(val_tensor).cpu().detach().numpy()","key":"iPcMJdSgxp"},{"type":"output","id":"hFbMw2x2LTEH7Sw8k-o4v","data":[],"key":"dBJZ8AV8J7"}],"key":"oDink2ETQ6"},{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"# calculate the confidence and predictions\nprobas = np.exp(logprobas)\npredictions = encoder.classes_[probas.argmax(axis=1)]","key":"KgDCjyUGqt"},{"type":"output","id":"_kVALj6KuyLvJbrGhxv6F","data":[],"key":"gsddiHoY63"}],"key":"xhLZ7JXnx0"},{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"# Calculate Accuracy, Precision and Recall, F1-Score\ny_true = y_validate[val_sample_mask]\nlabels = sorted(set(y_true) | set(predictions))\n\naccuracy = accuracy_score(y_true, predictions)\nprecision = precision_score(y_true, predictions, average=None, labels=labels)\nrecall = recall_score(y_true, predictions, average=None, labels=labels)\nf1 = f1_score(y_true, predictions, average=None, labels=labels)","key":"XjzSERGnY0"},{"type":"output","id":"bpWeLAD522afat6v-FNgt","data":[],"key":"gNByOpIgtM"}],"key":"obLTfuYJbD"},{"type":"block","kind":"notebook-content","data":{},"children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Plot F1-score per label","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"KMOzZyWQcI"}],"key":"olUVVQVlgC"}],"key":"IM7I9DwWyb"},{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"fig, ax = plt.subplots(figsize=(12, 5))\n\n# calculate F1 score dataframe\ndf_f1 = pd.DataFrame({\"Code\": lbl, \"Label\": [labels_dict[lbl] for lbl in labels], \"F1 score\": f1})\n\n# plot scores\nax.barh(df_f1[\"Label\"], df_f1[\"F1 score\"])\n\nax.set_title(\"Labels F1-Score\")\nax.set_xlabel(\"F1-Score\")","key":"ckM6g8W4Xn"},{"type":"output","id":"JrYnT-VBh7PyHIuEchCQ9","data":[],"key":"e2FqHh8dmJ"}],"key":"ylE316aOKo"},{"type":"block","kind":"notebook-content","data":{},"children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Plot confusion matrix","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"clAEXUcfBT"}],"key":"v7WaWZiO6S"}],"key":"Z6Ih6anNAQ"},{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"true_labels_counts_dict = dict(zip(*np.unique(y_validate[val_sample_mask].tolist(), return_counts=True)))\ncounts = [true_labels_counts_dict.get(lbl, 0) for lbl in labels]\n\nlabels = np.array(labels)[np.argsort(counts)[::-1]]\ncounts = sorted(counts)[::-1]\n\ncm = confusion_matrix(y_true, predictions, normalize=\"true\", labels=labels)\nax = sns.heatmap(\n    cm,\n    annot=True,\n    cmap=\"Greens\",\n    fmt=\".2f\",\n    xticklabels=[labels_dict[lbl] for lbl in labels],\n    yticklabels=[f\"{labels_dict[lbl]}\\n({c})\" for lbl, c in zip(labels, counts)],\n    cbar=False,\n    annot_kws={\"color\": \"black\"},\n)\nax.set_xlabel(\"Predicted labes\")\nax.set_ylabel(\"True labels\")\nax.set_title(\"Confusion matrix\")\nplt.show()","key":"ZdPllBl7RZ"},{"type":"output","id":"UhdYt3Sq7bUgVSP9gDBsy","data":[],"key":"f0s2uioKnJ"}],"key":"ywnm4zpKun"},{"type":"block","kind":"notebook-content","data":{},"children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Plot time series according to the true label","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"w0TgQ30ogM"}],"key":"MxIsJ45CCZ"}],"key":"W519IPvGxc"},{"type":"block","kind":"notebook-code","data":{},"children":[{"type":"code","lang":"python","executable":true,"value":"ncols = 3\nnrows = len(encoder.classes_) // ncols + 1\n\nfig, axs = plt.subplots(figsize=(15, 7), nrows=nrows, ncols=ncols)\n\nn, t, c = x_validate.shape\nplot_data = val_scaler.inverse_transform(x_validate.reshape(n * t, c)).reshape(n, t, c)[val_sample_mask]\nndvi = (plot_data[..., 3] - plot_data[..., 2]) / (plot_data[..., 3] + plot_data[..., 2])\n\nfor idx, (ax, cc) in enumerate(zip(axs.ravel(), encoder.classes_)):\n    ax.plot(ndvi[y_true == cc][:200].T, color=f\"C{idx}\", alpha=0.1)\n    ax.set_title(f\"Crop Type {cc} ({labels_dict[cc]})\")\n\nplt.tight_layout()","key":"Ah4sIC3YY5"},{"type":"output","id":"1DQDveKiSMGeugzyKzNNh","data":[],"key":"uETqm3Wspb"}],"key":"Eyb5eWJZGD"},{"type":"block","kind":"notebook-content","data":{},"children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Plot time series according to the predicted label","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"No64RxhyV2"}],"key":"z9NLQxPcli"}],"key":"hi0G9bP318"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"ncols = 3\nnrows = len(encoder.classes_) // ncols + 1\n\nfig, axs = plt.subplots(figsize=(15, 7), nrows=nrows, ncols=ncols)\n\nfor idx, (ax, cc) in enumerate(zip(axs.ravel(), encoder.classes_)):\n    ax.plot(ndvi[predictions == cc][:200].T, color=f\"C{idx}\", alpha=0.1)\n    ax.set_title(f\"Crop Type {cc} ({labels_dict[cc]})\")\n\nplt.tight_layout()","visibility":"show","key":"K1OvmtAMIm"},{"type":"output","id":"7Kr5qMCHSJUq2bjouXVK2","data":[],"visibility":"show","key":"XcCENGWuhu"}],"visibility":"show","key":"kyP0RcgJaR"}],"key":"EAk2Jfhc0r"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Demonstration of Eurocrops data use in geoDB","url":"/external-notebooks/eurodatacube/notebooks/notebooks/contributions/edc-geodb-4-eurocrops-demo","group":"Contributions"},"next":{"title":"Important notes","url":"/external-notebooks/eurodatacube/notebooks/notebooks/contributions/edc-usecase-lpis-crop-type-classification","group":"Contributions"}}},"domain":"http://localhost:3000"}